"""Step 06: Fetch TMDb
Fetches popular movies from TMDb API using Discover endpoint (more pages than Top Rated).
Defaults to top 1,000 but configurable (self.max_movies).
Supports ROW_LIMIT for debugging and Golden Test Mode for iconic films.
Writes enriched_top_1000.csv (or larger) to TMDB_DIR.
"""

from base_step import BaseStep
import requests
import pandas as pd
from config import TMDB_DIR, TMDB_API_KEY, ROW_LIMIT, DEBUG_MODE, TMDB_PAGE_LIMIT, GOLDEN_TITLES, GOLDEN_EXPECTED_YEARS, GOLDEN_TEST_MODE
from tqdm import tqdm


class Step06FetchTMDb(BaseStep):
    def __init__(self, name="Step 06: Fetch TMDb Discover"):
        super().__init__(name=name)
        self.api_key = TMDB_API_KEY
        self.output_path = TMDB_DIR / "enriched_top_1000.csv"
        self.max_movies = 1000  # default upper bound (overridden by ROW_LIMIT or Golden Mode)

    def run(self):
        if not self.api_key:
            raise RuntimeError("TMDB_API_KEY not set")

        if GOLDEN_TEST_MODE:
            self.logger.info(f"ðŸ”Ž Golden Test Mode active: fetching {len(GOLDEN_TITLES)} iconic movies by search")
            movies = self._fetch_golden(GOLDEN_TITLES)
        else:
            # Apply ROW_LIMIT if set, capped to TMDb API max (~10,000)
            effective_limit = min(ROW_LIMIT, 10000)
            self.logger.info(f"â–¶ Fetching up to {effective_limit:,} TMDb moviesâ€¦")
            genre_map = self._fetch_genre_map()
            movies = self._fetch_discover_movies(effective_limit, genre_map)

        df = pd.DataFrame(movies)
        self.output_path.parent.mkdir(parents=True, exist_ok=True)
        df.to_csv(self.output_path, index=False)
        self.logger.info(f"âœ… Wrote {len(df)} rows to {self.output_path}")

        # ðŸ“ Write fresh documentation file
        doc_text = f"""
Step 06 Output Documentation
============================

Generated by Step 06: Fetch TMDb Movies

File Produced:
--------------
- enriched_top_1000.csv
  Schema:
    tmdb_id, title, release_year, genres

Modes:
------
- Golden Test Mode: {GOLDEN_TEST_MODE}
  (Titles: {len(GOLDEN_TITLES)} iconic films if enabled)
- ROW_LIMIT: {ROW_LIMIT or "âˆž"}
- Default max_movies: {self.max_movies}

Notes:
------
- Golden Test Mode overrides ROW_LIMIT.
- TMDb discover endpoint limited to 500 pages (â‰ˆ10,000 movies).
"""
        doc_path = TMDB_DIR / "Step06_Documentation.txt"
        with open(doc_path, "w", encoding="utf-8") as f:
            f.write(doc_text)

        self.logger.info(f"ðŸ“ Wrote fresh documentation to {doc_path}")

    def _fetch_discover_movies(self, limit: int, genre_map: dict) -> list[dict]:
        """Fetch popular movies using Discover API (max 500 pages)."""
        url = "https://api.themoviedb.org/3/discover/movie"
        movies = []
        page = 1
        per_page = 20
        max_pages = 500  # TMDb API hard limit

        with tqdm(total=limit, desc="Fetching TMDb") as bar:
            while len(movies) < limit and page <= max_pages:
                r = requests.get(url, params={
                    "api_key": self.api_key,
                    "page": page,
                    "sort_by": "popularity.desc",
                    "language": "en-US",
                    "include_adult": "false"
                })
                r.raise_for_status()
                data = r.json()
                results = data.get("results", [])
                if not results:
                    break

                for m in results:
                    tmdb_id = m.get("id")
                    title = m.get("title", "")
                    rd = m.get("release_date") or ""
                    try:
                        year = int(rd.split("-")[0])
                    except:
                        year = None
                    genre_ids = m.get("genre_ids", [])
                    genres = "|".join(genre_map.get(gid, "") for gid in genre_ids)
                    movies.append({
                        "tmdb_id": tmdb_id,
                        "title": title,
                        "release_year": year,
                        "genres": genres
                    })
                    bar.update(1)
                    if len(movies) >= limit:
                        break

                if page >= max_pages or page >= data.get("total_pages", page):
                    self.logger.info(f"ðŸ›‘ Reached TMDb page cap ({max_pages}); stopping at {len(movies):,} movies.")
                    break

                page += 1

        return movies

    def _fetch_golden(self, titles: set[str]) -> list[dict]:
        """Fetch golden movies by searching TMDb titles from config.GOLDEN_TITLES with year disambiguation."""
        url = "https://api.themoviedb.org/3/search/movie"
        movies = []
        for title in tqdm(titles, desc="Fetching Golden Set"):
            r = requests.get(url, params={"api_key": self.api_key, "query": title, "language": "en-US"})
            r.raise_for_status()
            results = r.json().get("results", [])
            if not results:
                self.logger.warning(f"âš ï¸ No TMDb result for golden title: {title}")
                continue

            expected_year = GOLDEN_EXPECTED_YEARS.get(title)

            # Pick best candidate: prefer correct year if available
            chosen = results[0]
            if expected_year:
                for cand in results:
                    rd = cand.get("release_date") or ""
                    try:
                        year = int(rd.split("-")[0])
                    except:
                        year = None
                    if year == expected_year:
                        chosen = cand
                        break

            rd = chosen.get("release_date") or ""
            try:
                year = int(rd.split("-")[0])
            except:
                year = None
            genres = "|".join(str(gid) for gid in chosen.get("genre_ids", []))

            movies.append({
                "tmdb_id": chosen.get("id"),
                "title": chosen.get("title", ""),
                "release_year": year,
                "genres": genres
            })

        return movies

    def _fetch_genre_map(self) -> dict[int, str]:
        url = "https://api.themoviedb.org/3/genre/movie/list"
        r = requests.get(url, params={"api_key": self.api_key, "language": "en-US"})
        r.raise_for_status()
        data = r.json().get("genres", [])
        return {g["id"]: g["name"] for g in data}


if __name__ == "__main__":
    step = Step06FetchTMDb()
    step.run()
