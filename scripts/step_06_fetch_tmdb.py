"""Step 06: Fetch TMDb
Fetches top-rated movies from TMDb API.
Defaults to top 1,000 but configurable (self.max_movies).
Supports ROW_LIMIT for debugging and Golden Test Mode for iconic films.
Writes enriched_top_1000.csv (or larger) to TMDB_DIR.
"""

from base_step import BaseStep
import requests
import pandas as pd
from config import TMDB_DIR, TMDB_API_KEY, ROW_LIMIT, GOLDEN_TITLES, GOLDEN_EXPECTED_YEARS, GOLDEN_TEST_MODE
from tqdm import tqdm


class Step06FetchTMDb(BaseStep):
    def __init__(self, name="Step 06: Fetch TMDb Top 1000"):
        super().__init__(name="Step 06: Fetch TMDb Top 1000")
        self.api_key = TMDB_API_KEY
        self.output_path = TMDB_DIR / "enriched_top_1000.csv"
        self.max_movies = 1000  # default upper bound (overridden by ROW_LIMIT or Golden Mode)

    def run(self):
        if not self.api_key:
            raise RuntimeError("TMDB_API_KEY not set")

        if GOLDEN_TEST_MODE:
            self.logger.info(f"🔎 Golden Test Mode active: fetching {len(GOLDEN_TITLES)} iconic movies by search")
            movies = self._fetch_golden(GOLDEN_TITLES)
        else:
            # Apply ROW_LIMIT if set (overrides max_movies)
            effective_limit = ROW_LIMIT if ROW_LIMIT else self.max_movies
            self.logger.info(f"▶ Fetching up to {effective_limit:,} TMDb movies…")
            genre_map = self._fetch_genre_map()
            movies = self._fetch_top_rated(effective_limit, genre_map)

        df = pd.DataFrame(movies)
        self.output_path.parent.mkdir(parents=True, exist_ok=True)
        df.to_csv(self.output_path, index=False)
        self.logger.info(f"✅ Wrote {len(df)} rows to {self.output_path}")

        # 📝 Write fresh documentation file
        doc_text = f"""
Step 06 Output Documentation
============================

Generated by Step 06: Fetch TMDb Movies

File Produced:
--------------
- enriched_top_1000.csv
  Schema:
    tmdb_id, title, release_year, genres

Modes:
------
- Golden Test Mode: {GOLDEN_TEST_MODE}
  (Titles: {len(GOLDEN_TITLES)} iconic films if enabled)
- ROW_LIMIT: {ROW_LIMIT or "∞"}
- Default max_movies: {self.max_movies}

Notes:
------
- Golden Test Mode overrides ROW_LIMIT.
- If neither is active, fetches top {self.max_movies} movies from TMDb.
"""
        doc_path = TMDB_DIR / "Step06_Documentation.txt"
        with open(doc_path, "w", encoding="utf-8") as f:
            f.write(doc_text)

        self.logger.info(f"📝 Wrote fresh documentation to {doc_path}")

    def _fetch_top_rated(self, limit: int, genre_map: dict) -> list[dict]:
        """Fetch top-rated movies, up to limit."""
        url = "https://api.themoviedb.org/3/movie/top_rated"
        movies = []
        page = 1

        with tqdm(total=limit, desc="Fetching TMDb") as bar:
            while len(movies) < limit:
                r = requests.get(url, params={"api_key": self.api_key, "page": page, "language": "en-US"})
                r.raise_for_status()
                data = r.json()
                results = data.get("results", [])
                if not results:
                    break

                for m in results:
                    tmdb_id = m.get("id")
                    title   = m.get("title", "")
                    rd      = m.get("release_date") or ""
                    try:
                        year = int(rd.split("-")[0])
                    except:
                        year = None
                    genre_ids = m.get("genre_ids", [])
                    genres = "|".join(genre_map.get(gid, "") for gid in genre_ids)

                    movies.append({
                        "tmdb_id": tmdb_id,
                        "title": title,
                        "release_year": year,
                        "genres": genres
                    })

                    bar.update(1)
                    if len(movies) >= limit:
                        break

                self.logger.info(f"   • Page {page}, collected {len(movies)} total")
                page += 1
                if page > data.get("total_pages", 1):
                    break

        return movies

    def _fetch_golden(self, titles: set[str]) -> list[dict]:
        """Fetch golden movies by searching TMDb titles from config.GOLDEN_TITLES with year disambiguation."""
        url = "https://api.themoviedb.org/3/search/movie"
        movies = []
        for title in tqdm(titles, desc="Fetching Golden Set"):
            r = requests.get(url, params={"api_key": self.api_key, "query": title, "language": "en-US"})
            r.raise_for_status()
            results = r.json().get("results", [])
            if not results:
                self.logger.warning(f"⚠️ No TMDb result for golden title: {title}")
                continue

            expected_year = GOLDEN_EXPECTED_YEARS.get(title)

            # Pick best candidate: prefer correct year if available
            chosen = results[0]
            if expected_year:
                for cand in results:
                    rd = cand.get("release_date") or ""
                    try:
                        year = int(rd.split("-")[0])
                    except:
                        year = None
                    if year == expected_year:
                        chosen = cand
                        break

            rd = chosen.get("release_date") or ""
            try:
                year = int(rd.split("-")[0])
            except:
                year = None
            genres = "|".join(str(gid) for gid in chosen.get("genre_ids", []))

            movies.append({
                "tmdb_id": chosen.get("id"),
                "title": chosen.get("title", ""),
                "release_year": year,
                "genres": genres
            })

        return movies

    def _fetch_genre_map(self) -> dict[int, str]:
        url = "https://api.themoviedb.org/3/genre/movie/list"
        r = requests.get(url, params={"api_key": self.api_key, "language": "en-US"})
        r.raise_for_status()
        data = r.json().get("genres", [])
        return {g["id"]: g["name"] for g in data}

if __name__ == "__main__":
    step = Step06FetchTMDb()
    step.run()